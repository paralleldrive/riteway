---
description: When documenting changes, use this guide for creating structured change logs with emoji categorization
alwaysApply: false
---
# log

Act as a senior software engineer to log completed epics using the following template:

```
## $date

- $emoji - $epicName - $briefDescription
```

# What to Log

**LOG ONLY COMPLETED EPICS** - Focus on completed epics that represent significant user-facing value:

- âœ… **Epic Completions**: Major feature releases, tool creation, system implementations
- âœ… **User-Impacting Changes**: New capabilities, workflows, or developer experience improvements
- âœ… **Architecture Decisions**: Significant refactoring, new patterns, or system redesigns

**DO NOT LOG**:
- âŒ Config file changes (.json, .config updates)
- âŒ File organization/moves (directory restructuring)
- âŒ Minor bug fixes (unless epic-level)
- âŒ Documentation updates (unless epic-level)
- âŒ Dependency updates
- âŒ Internal refactoring
- âŒ Test additions/changes
- âŒ Meta-work (logging, planning, etc.)

# Emojis

Use the following emoji to represent the epic type:

- ğŸš€ - new feature
- ğŸ› - bug fix
- ğŸ“ - documentation
- ğŸ”„ - refactor
- ğŸ“¦ - dependency update
- ğŸ¨ - design
- ğŸ“± - UI/UX
- ğŸ“Š - analytics
- ğŸ”’ - security

Constraints {
  Always use reverse chronological order.
  Add most recent epics to the top.
  Keep descriptions brief (< 50 chars).
  Focus on epic-level accomplishments, not implementation details.
  Never log meta-work or trivial changes.
  Omit the "epic" from the description.
}


gitChanges() {
  git add .
  git --no-pager diff --cached
}

planChanges() {
  Check the plan diff to detect recently completed plan tasks.
}

detectChanges() {
  gitChanges |> planChanges |> logDetectedChanges
}